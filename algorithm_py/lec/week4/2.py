### 과제2.

'''
오름차순으로 정렬된 N개의 정수를 가진 List가 주어져있을 때, 해당 List에 존재하는 서로 다른 값이 몇 가지인지 알아내는 알고리즘을 구현하라. 알고리즘의 제약사항은 아래와 같다. (알고리즘은 1 <= N <= 10000에서 테스트된다.)

추가 메모리 사용은 O(1)으로 제한된다. 따라서 set()와 dict() 등의 자료구조를 사용할 수 없다.
알고리즘의 시간복잡도는 O(N) 이하로 제한된다.
'''

'''
def countUniques(a):
    pass
 
# Test code
print(countUniques([-1, 1, 1, 1, 1, 4, 4, 4, 4, 10, 14, 14])) # 출력 5
print(countUniques([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])) # 츨력 2
'''

# 내 풀이 ----------------------------------------------------------------------------

def countUniques(a):    
    # 공간복잡도 O(1) : 변수 1개(카운트)만 선언
    # 시간복잡도 O(N) : 반복문 1개 내에서, sorting 되어 있다는 전제이기 때문에 앞뒤 값이 다를 경우에만 cnt++하면 된다

    cnt = 1         # 맨 처음 시작 변수 +해줘야됨, 0 말고 1로 초기값 설정
    for i in range(len(a) - 1):
        if a[i] != a[i+1]:            
            cnt += 1                    
    return cnt




# Test code
print(countUniques([-1, 1, 1, 1, 1, 4, 4, 4, 4, 10, 14, 14])) # 5
print(countUniques([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])) # 2

# 강사님 풀이 ------------------------------------------------------------------------- 
#정렬된 리스트의 특성을 이용하여 주어진 스펙에 맞는 알고리즘을 구현하는 문제였습니다.
#O(n)의 시간 복잡도와 O(1)의 공간 복잡도를 만족시키도록 잘 구현해 주셨습니다! :)

def countUniques(a):
    last_el = None
    count = 0
    for el in a:
        if last_el != el:
            count += 1
        last_el = el
    return count
 
print(countUniques([-1, 1, 1, 1, 1, 4, 4, 4, 4, 10, 14, 14])) # 5
print(countUniques([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])) # 2